<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>定点乘法运算：Booth算法（补码一位乘法）C实现</title>
    <url>/2019/11/07/%E5%AE%9A%E7%82%B9%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%9ABooth%E7%AE%97%E6%B3%95%EF%BC%88%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%EF%BC%89C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<p>参考：<a href="https://blog.csdn.net/ZYZMZM_/article/details/89530121" target="_blank" rel="noopener">https://blog.csdn.net/ZYZMZM_/article/details/89530121</a></p>
<br>

<h1 id="定点数乘法运算"><a href="#定点数乘法运算" class="headerlink" title="定点数乘法运算"></a>定点数乘法运算</h1><br>

<p>在计算机中，乘法运算由<font color="blue">累加和右移</font>操作实现。根据机器数的不同，可分为<br>&emsp;&emsp;<strong>✦&emsp;原码一位乘法</strong><br>&emsp;&emsp;<strong>✦&emsp;补码一位乘法</strong><br>原码一位乘法的规则比补码一位乘法简单。我们下面主要介绍<font color="blue">补码一位乘法（Booth）算法。</font><br><br>由于补码加减较原码加减简单，在通用计算机中常采用补码表示，从存储器中读得的操作数是补码表示的机器数。如果同一运算部件对加减运算采用补码算法，而对乘法运算又采用原码算法，就需要进行码制转换，因而不太方便，这就需要寻求补码乘法。<font color="blue">补码乘法是指：操作数与结果均以补码表示，连同符号位一起，按相应算法运算。</font></p>
<br>

<h1 id="Booth算法分析"><a href="#Booth算法分析" class="headerlink" title="Booth算法分析"></a>Booth算法分析</h1><br>

<p>这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积。</p>
<p>设 [X]补 = Xs.X1X2···Xn， [Y]补 = Ys.Y1Y2···Yn，则运算规则如下：</p>
<p>&emsp;&emsp;●&emsp;<strong>符号位参与运算</strong>，运算的数均以<strong>补码</strong>表示<br>&emsp;&emsp;●&emsp;<strong>被乘数</strong>一般取<strong>双符号位</strong>参与运算，<strong>部分积</strong>取<strong>双符号位</strong>，初值为0，<strong>乘数</strong>可取<strong>单符号位</strong><br>&emsp;&emsp;●&emsp;乘数末尾增设附加位Yn+1，且初值为0<br>&emsp;&emsp;●&emsp;根据（Yn，Yn+1）的值来确定操作，具体见下表<br>&emsp;&emsp;●&emsp;移位按照<strong>补码右移规则</strong>进行<br>&emsp;&emsp;●&emsp;按照上述算法进行 n+1 步操作，但 <strong><font color="red"> n + 1步不再移位</font></strong>（共进行 n + 1 次累加和 n次右移），仅根据Yn 与 Yn+1 的比较结果做相应的运算。<br><img src="https://i.loli.net/2019/11/07/4ubaqsRgTZ3CMnE.png" width="75%" height="75%" div align="center"><br><strong><em>实例：</em></strong><br><img src="https://i.loli.net/2019/11/07/TR7xkhGHLfoVUdb.jpg" width="75%" height="75%" div align="center"><br><img src="https://i.loli.net/2019/11/07/dV2uTnHSG6NQeLq.jpg" width="75%" height="75%" div align="center"></p>
<br>

<h1 id="Booth算法的C实现"><a href="#Booth算法的C实现" class="headerlink" title="Booth算法的C实现"></a>Booth算法的C实现</h1><br>

<p>你可以把整个文件项目clone到你的本地仓库。<a href="https://github.com/dengjia-lib/code/tree/master" target="_blank" rel="noopener">dengjia-lib/code</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* 存储被乘数 x 的补码 */</span><br><span class="line">char xCom[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">/* 存储 -x 的补码 */</span><br><span class="line">char mxCom[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">/* 存储乘数 y 的补码 */</span><br><span class="line">char yCom[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">/* 存储乘数 y 末位增加 0 */</span><br><span class="line">char multiNum[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">/* 存储部分积的初值 */</span><br><span class="line">char multiSrc[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">/* 计算字符串长度 */</span><br><span class="line">int length(char* ch)</span><br><span class="line">&#123;</span><br><span class="line">	int len = 0;</span><br><span class="line">	while (*ch != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		++len;</span><br><span class="line">		++ch;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 拷贝字符串 */</span><br><span class="line">char* copy(char* dest, const char* src)</span><br><span class="line">&#123;</span><br><span class="line">	char* tmp = dest;</span><br><span class="line">	while (*dest++ = *src++) &#123;&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 字符串比较 */</span><br><span class="line">int compare(const char* dest, const char* src)</span><br><span class="line">&#123;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	while (!(tmp = *dest - *src) &amp;&amp; *dest &amp;&amp; *src)</span><br><span class="line">	&#123;</span><br><span class="line">		dest++;</span><br><span class="line">		src++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (tmp &gt; 0) &#123; return 1; &#125;</span><br><span class="line">	else if (tmp &lt; 0) &#123; return -1; &#125;</span><br><span class="line">	else &#123; return 0; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 字符串截取：截取从src中的begin下标到end下标的字符串，结果存储在res中 */</span><br><span class="line">char* intercept(char* src, char *res, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">	int i = begin;</span><br><span class="line">	int j = 0;</span><br><span class="line">	while (i &lt;= end)</span><br><span class="line">	&#123;</span><br><span class="line">		res[j] = src[i];</span><br><span class="line">		++j;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 右移 */</span><br><span class="line">void mRight(char* src)</span><br><span class="line">&#123;</span><br><span class="line">	int len = length(src);</span><br><span class="line">	int i = len - 1;</span><br><span class="line"></span><br><span class="line">	/* 获取小数部分的起始位置 */</span><br><span class="line">	int num = 0;</span><br><span class="line">	char* p = src;</span><br><span class="line">	while (*p != &apos;.&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		++num;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	++num;</span><br><span class="line"></span><br><span class="line">	/* 将小数后的第一位空出，其余全部后移 */</span><br><span class="line">	for (; i &gt;= num; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		src[i + 1] = src[i];</span><br><span class="line">	&#125;</span><br><span class="line">	++i;</span><br><span class="line"></span><br><span class="line">	/* 根据正负进行添1 或 添0 */</span><br><span class="line">	if (src[0] == &apos;1&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		src[i] = &apos;1&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		src[i] = &apos;0&apos;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 浮点数加法 */</span><br><span class="line">void Add(char* lhsstr, char *rhsstr, char *result)</span><br><span class="line">&#123;</span><br><span class="line">	int lhsLen = length(lhsstr);</span><br><span class="line">	int rhsLen = length(rhsstr);</span><br><span class="line"></span><br><span class="line">	/* 对长度较小的数字，在其后补0，目的是为了使两数长度相同 */</span><br><span class="line">	if (lhsLen &lt; rhsLen)</span><br><span class="line">	&#123;</span><br><span class="line">		int diff = rhsLen - lhsLen;</span><br><span class="line">		int i = lhsLen;</span><br><span class="line">		while (diff &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			lhsstr[i] = &apos;0&apos;;</span><br><span class="line">			--diff;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (lhsLen &gt; rhsLen)</span><br><span class="line">	&#123;</span><br><span class="line">		int diff = lhsLen - rhsLen;</span><br><span class="line">		int i = rhsLen;</span><br><span class="line">		while (diff &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			rhsstr[i] = &apos;0&apos;;</span><br><span class="line">			--diff;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 拿到最大的长度 */</span><br><span class="line">	int i = lhsLen &lt;= rhsLen ? rhsLen - 1 : lhsLen - 1;</span><br><span class="line">	int j = i;</span><br><span class="line"></span><br><span class="line">	/* 进位标志 */</span><br><span class="line">	int flag = 0;</span><br><span class="line"></span><br><span class="line">	while (i &gt;= 0)</span><br><span class="line">	&#123;</span><br><span class="line">		/* 小数点跳过 */</span><br><span class="line">		if (lhsstr[i] == &apos;.&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			result[i] = &apos;.&apos;;</span><br><span class="line">			--i;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 小数点跳过 */</span><br><span class="line">		if (rhsstr[j] == &apos;.&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			result[j] = &apos;.&apos;;</span><br><span class="line">			--j;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int lhs = lhsstr[i] - &apos;0&apos;;</span><br><span class="line">		int rhs = rhsstr[j] - &apos;0&apos;;</span><br><span class="line"></span><br><span class="line">		int sum = lhs + rhs;</span><br><span class="line"></span><br><span class="line">		if (flag == 1)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += 1;</span><br><span class="line">			flag = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 和为2，则需要进位，存储0，更新进位标志 */</span><br><span class="line">		if (sum == 2)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 1;</span><br><span class="line">			sum = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 和为3，即之前有进位，且现在和为2也有进位，即11，存储1，更新进位标志 */</span><br><span class="line">		else if (sum == 3)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 1;</span><br><span class="line">			sum = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		result[i] = sum + &apos;0&apos;;</span><br><span class="line">		--i;</span><br><span class="line">		--j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 原码转补码 */</span><br><span class="line">void calComplement(char *origin, char *recv)</span><br><span class="line">&#123;</span><br><span class="line">	/* 负数标志 */</span><br><span class="line">	int isMinus = 0;</span><br><span class="line">	if (origin[0] == &apos;-&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		isMinus = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char* result = origin;</span><br><span class="line"></span><br><span class="line">	/* 原码为负，补码--&gt; 原码变反加一 */</span><br><span class="line">	if (isMinus)</span><br><span class="line">	&#123;</span><br><span class="line">		/* -0.1101  -&gt; 11.xxxx */</span><br><span class="line">		*origin++ = &apos;1&apos;;</span><br><span class="line">		*origin++ = &apos;1&apos;;</span><br><span class="line"></span><br><span class="line">		/* 小数位全部变反 */</span><br><span class="line">		while (*origin != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			if (*origin == &apos;1&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				*origin = &apos;0&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (*origin == &apos;0&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				*origin = &apos;1&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">			++origin;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* 加一操作：构造和操作数长度相同的加数，即 11.xxxx + 00.0001 */</span><br><span class="line">		int len = length(result);</span><br><span class="line">		char rhs[20] = &#123; 0 &#125;;</span><br><span class="line">		rhs[0] = &apos;0&apos;;</span><br><span class="line">		rhs[1] = &apos;0&apos;;</span><br><span class="line">		rhs[2] = &apos;.&apos;;</span><br><span class="line">		rhs[len - 1] = &apos;1&apos;;</span><br><span class="line">		for (int i = len - 2; i &gt; 2; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			rhs[i] = &apos;0&apos;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Add(result, rhs, recv);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 原码为正，补码不改变，但在这里给补码前补0，即 0.1011 --&gt; 00.1011 */</span><br><span class="line">	int len = length(origin);</span><br><span class="line">	for (int i = len - 1; i &gt;= 0; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		origin[i + 1] = origin[i];</span><br><span class="line">	&#125;</span><br><span class="line">	origin[0] = &apos;0&apos;;</span><br><span class="line">	copy(recv, origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 补码转原码：最后的结果转换 */</span><br><span class="line">void calOri(char* origin, char* recv)</span><br><span class="line">&#123;</span><br><span class="line">	/* 负数标志 */</span><br><span class="line">	int isMinus = 0;</span><br><span class="line">	if (origin[0] == &apos;1&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		isMinus = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char* result = origin;</span><br><span class="line"></span><br><span class="line">	/* 补码的符号位为负 */</span><br><span class="line">	if (isMinus)</span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		multiRes : 11.01110001</span><br><span class="line">		X * Y COM : 1.01110001</span><br><span class="line">		X * Y : -0.10001111</span><br><span class="line">		*/</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		** 11.XXXXX --&gt; -0.XXXXX（通过multiRes补码</span><br><span class="line">		** 转换，因为11恰好可用-0，都是两位，直接替换）</span><br><span class="line">		*/</span><br><span class="line">		*origin++ = &apos;-&apos;;</span><br><span class="line">		*origin++ = &apos;0&apos;;</span><br><span class="line"></span><br><span class="line">		/* 按位取反 */</span><br><span class="line">		while (*origin != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			if (*origin == &apos;1&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				*origin = &apos;0&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (*origin == &apos;0&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				*origin = &apos;1&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">			++origin;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* 加一操作 */</span><br><span class="line">		int len = length(result);</span><br><span class="line">		char rhs[20] = &#123; 0 &#125;;</span><br><span class="line">		rhs[0] = &apos;0&apos;;</span><br><span class="line">		rhs[1] = &apos;0&apos;;</span><br><span class="line">		rhs[2] = &apos;.&apos;;</span><br><span class="line">		rhs[len - 1] = &apos;1&apos;;</span><br><span class="line">		for (int i = len - 2; i &gt; 2; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			rhs[i] = &apos;0&apos;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Add(result, rhs, recv);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 补码符号位为正，即原码和补码相同 */</span><br><span class="line">	//copy(recv, origin);</span><br><span class="line">	if (!isMinus) &#123;</span><br><span class="line">		int len = length(origin);</span><br><span class="line">		int m = 0;</span><br><span class="line">		for (; m &lt; len - 1; ++m)</span><br><span class="line">		&#123;</span><br><span class="line">			origin[m] = origin[m + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		origin[m] = &apos;\0&apos;;</span><br><span class="line">		copy(recv, origin);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* booth算法核心实现 */</span><br><span class="line">void Calculate()</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	char index[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	/* 拿到末尾添0的乘数副本 */</span><br><span class="line">	copy(index, multiNum);</span><br><span class="line"></span><br><span class="line">	/* 计算小数部分起始位置 */</span><br><span class="line">	int num = 0;</span><br><span class="line">	while (index[i] != &apos;.&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		++num;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 去掉index的小数点，便于之后进行移位分割 */</span><br><span class="line">	char res[20] = &#123; 0 &#125;;</span><br><span class="line">	int len = length(index);</span><br><span class="line">	for (i = num; i &lt; len - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		index[i] = index[i + 1];</span><br><span class="line">	&#125;</span><br><span class="line">	index[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	i = length(index) - 1;</span><br><span class="line"></span><br><span class="line">	/* 首次计算标志，因为首次计算是与部分积初值的计算 */</span><br><span class="line">	int first = 1;</span><br><span class="line"></span><br><span class="line">	/* 存储部分积 */</span><br><span class="line">	char multiRes[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	while (i - 1 &gt;= 0)</span><br><span class="line">	&#123;</span><br><span class="line">		/* 移位分割，从低位向高位分割，分割首末位置每次同时向高位移动一位 */</span><br><span class="line">		intercept(index, res, i - 1, i);</span><br><span class="line"></span><br><span class="line">		/* 首次是与初值的运算 */</span><br><span class="line">		if (first)</span><br><span class="line">		&#123;</span><br><span class="line">			first = 0;</span><br><span class="line">			if (compare(res, &quot;00&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 00 --&gt; 初值右移一位 */</span><br><span class="line">				mRight(multiSrc);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;01&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 01 --&gt; 初值加[x]补，并右移一位 */</span><br><span class="line">				Add(multiSrc, xCom, multiRes);</span><br><span class="line">				mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;10&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 10 --&gt; 初值加[-x]补，并右移一位 */</span><br><span class="line">				Add(multiSrc, mxCom, multiRes);</span><br><span class="line">				mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;11&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 初值右移一位 */</span><br><span class="line">				mRight(multiSrc);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 非首次都是与部分积的运算 */</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			/* 00 --&gt; 部分积右移一位 */</span><br><span class="line">			if (compare(res, &quot;00&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				if (i - 1 &gt; 0)</span><br><span class="line">					mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;01&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 01 --&gt; 部分积加[x]补，并右移一位 */</span><br><span class="line">				Add(multiRes, xCom, multiRes);</span><br><span class="line">				if (i - 1 &gt;0)</span><br><span class="line">					mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;10&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 10 --&gt; 部分积加[-x]补，并右移一位 */</span><br><span class="line">				Add(multiRes, mxCom, multiRes);</span><br><span class="line">				if (i - 1 &gt;0)</span><br><span class="line">					mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (compare(res, &quot;11&quot;) == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				/* 部分积右移一位 */</span><br><span class="line">				if (i - 1 &gt;0)</span><br><span class="line">					mRight(multiRes);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 部分积运算结果 */</span><br><span class="line">	printf(&quot;部分积运算结果 : %s\n&quot;, multiRes);</span><br><span class="line"></span><br><span class="line">	/* 拷贝运算结果，因为它会被下面计算补码时更改，但是计算原码时要用到它 */</span><br><span class="line">	char Ori[20] = &#123; 0 &#125;;</span><br><span class="line">	copy(Ori, multiRes);</span><br><span class="line"></span><br><span class="line">	/* 通过部分积得到补码 */</span><br><span class="line">	if (1)</span><br><span class="line">	&#123;</span><br><span class="line">		int mlen = length(multiRes);</span><br><span class="line">		i = 0;</span><br><span class="line">		for (; i &lt; mlen - 1; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			multiRes[i] = multiRes[i + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		multiRes[i] = &apos;\0&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;[X * Y]补 : %s\n&quot;, multiRes);</span><br><span class="line"></span><br><span class="line">	/* 通过部分积得到原码 */</span><br><span class="line">	char finalRes[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	calOri(Ori, finalRes);</span><br><span class="line">	printf(&quot;X * Y : %s\n&quot;, finalRes);</span><br><span class="line">	printf(&quot;-----------------------------------&quot;);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		char inputx[20] = &#123; 0 &#125;;</span><br><span class="line">		char inputy[20] = &#123; 0 &#125;;</span><br><span class="line">		</span><br><span class="line">		printf(&quot;==================== 补码一位乘法 ====================\n&quot;);</span><br><span class="line">		printf(&quot;******         【使用说明】           ******\n&quot;);</span><br><span class="line">		printf(&quot;******  请输入正数或是负数：          ******\n&quot;);</span><br><span class="line">		printf(&quot;******  第一位为‘0’来表示输入正数;  ******\n&quot;);</span><br><span class="line">		printf(&quot;******  第一位为‘-’来表示输入负数。 ******\n&quot;);</span><br><span class="line">		printf(&quot;******  输入&apos;w&apos;或&apos;W&apos;来重新输入。      ******\n&quot;);</span><br><span class="line">		printf(&quot;******  输入&apos;q&apos;或&apos;Q&apos;来退出。          ******\n&quot;);</span><br><span class="line">		printf(&quot;======================================================\n&quot;);</span><br><span class="line">		printf(&quot;请输入被乘数 X : &quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, inputx);</span><br><span class="line">		int flag = 0; //标志：退出还是重新写入。1：退出；2：重新写入</span><br><span class="line">		if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;//输入q退出</span><br><span class="line">		if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">			flag = 2;</span><br><span class="line">			printf(&quot;\n\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;//输入w重新写入</span><br><span class="line">		for (int i = 0; i &lt; length(inputx); i++) &#123;</span><br><span class="line">			if (inputx[0] == &apos;0&apos;) &#123;  //正数</span><br><span class="line">				if (inputx[1] == &apos;.&apos;) &#123;</span><br><span class="line">					while (inputx[i] != &apos;0&apos; &amp;&amp; inputx[i] != &apos;1&apos; &amp;&amp; i &gt; 1) &#123;</span><br><span class="line">						printf(&quot;[ERROR] 确保输入为正数，小数点后的数字是否正确？\n&quot;);</span><br><span class="line">						printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">						scanf(&quot;%s&quot;, inputx);</span><br><span class="line">						i = 0;</span><br><span class="line">						if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">							flag = 1;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">							flag = 2;</span><br><span class="line">							printf(&quot;\n\n&quot;);</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 1) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 2) &#123;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				while (inputx[1] != &apos;.&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 确保输入为正数，小数点的输入位置是否正确？\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputx);</span><br><span class="line">					if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">						flag = 2;</span><br><span class="line">						printf(&quot;\n\n&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 1) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 2) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (inputx[0] == &apos;-&apos;) &#123;  //负数</span><br><span class="line">				if (inputx[1] == &apos;0&apos;) &#123;</span><br><span class="line">					if (inputx[2] == &apos;.&apos;) &#123;</span><br><span class="line">						while (inputx[i] != &apos;0&apos; &amp;&amp; inputx[i] != &apos;1&apos; &amp;&amp; i &gt; 2) &#123;</span><br><span class="line">							printf(&quot;[ERROR] 确保输入为负数，小数点后的数字是否正确？\n&quot;);</span><br><span class="line">							printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">							scanf(&quot;%s&quot;, inputx);</span><br><span class="line">							i = 0;</span><br><span class="line">							if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">								flag = 1;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">							if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">								flag = 2;</span><br><span class="line">								printf(&quot;\n\n&quot;);</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						if (flag == 1) &#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (flag == 2) &#123;</span><br><span class="line">							continue;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					while (inputx[2] != &apos;.&apos;) &#123;</span><br><span class="line">						printf(&quot;[ERROR] 确保输入为负数，小数点的输入位置是否正确？\n&quot;);</span><br><span class="line">						printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">						scanf(&quot;%s&quot;, inputx);</span><br><span class="line">						if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">							flag = 1;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">							flag = 2;</span><br><span class="line">							printf(&quot;\n\n&quot;);</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 1) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 2) &#123;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				while (inputx[1] != &apos;0&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 确保输入为负数，要求输入负数的绝对值要&lt;1。\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputx);</span><br><span class="line">					if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">						flag = 2;</span><br><span class="line">						printf(&quot;\n\n&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 1) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 2) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;  //其他</span><br><span class="line">				while (inputx[0] != &apos;-&apos; &amp;&amp; inputx[0] != &apos;0&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 输入正数或负数，要求输入数的绝对值要&lt;1。\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入被乘数 X : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputx);</span><br><span class="line">					if (compare(inputx, &quot;q&quot;) == 0 || compare(inputx, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (compare(inputx, &quot;w&quot;) == 0 || compare(inputx, &quot;W&quot;) == 0) &#123;</span><br><span class="line">						flag = 2;</span><br><span class="line">						printf(&quot;\n\n&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag == 1) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag == 2) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;请输入乘数 Y : &quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, inputy);</span><br><span class="line">		if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">			flag = 2;</span><br><span class="line">			printf(&quot;\n\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; length(inputy); i++) &#123;</span><br><span class="line">			if (inputy[0] == &apos;0&apos;) &#123;</span><br><span class="line">				if (inputy[1] == &apos;.&apos;) &#123;</span><br><span class="line">					while (inputy[i] != &apos;0&apos; &amp;&amp; inputy[i] != &apos;1&apos; &amp;&amp; i &gt; 1) &#123;</span><br><span class="line">						printf(&quot;[ERROR] 确保输入为正数，小数点后的数字是否正确？\n&quot;);</span><br><span class="line">						printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">						scanf(&quot;%s&quot;, inputy);</span><br><span class="line">						i = 0;</span><br><span class="line">						if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">							flag = 1;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">							flag = 2;</span><br><span class="line">							printf(&quot;\n\n&quot;);</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 1) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 2) &#123;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				while (inputy[1] != &apos;.&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 确保输入为正数，小数点的输入位置是否正确？\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputy);</span><br><span class="line">					if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">						flag = 2;</span><br><span class="line">						printf(&quot;\n\n&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 1) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 2) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (inputy[0] == &apos;-&apos;) &#123;</span><br><span class="line">				if (inputy[1] == &apos;0&apos;) &#123;</span><br><span class="line">					if (inputy[2] == &apos;.&apos;) &#123;</span><br><span class="line">						while (inputy[i] != &apos;0&apos; &amp;&amp; inputy[i] != &apos;1&apos; &amp;&amp; i &gt; 2) &#123;</span><br><span class="line">							printf(&quot;[ERROR] 确保输入为负数，小数点后的数字是否正确？\n&quot;);</span><br><span class="line">							printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">							scanf(&quot;%s&quot;, inputy);</span><br><span class="line">							i = 0;</span><br><span class="line">							if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">								flag = 1;</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">							if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">								flag = 2;</span><br><span class="line">								printf(&quot;\n\n&quot;);</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						if (flag == 1) &#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (flag == 2) &#123;</span><br><span class="line">							continue;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					while (inputy[2] != &apos;.&apos;) &#123;</span><br><span class="line">						printf(&quot;[ERROR] 确保输入为负数，小数点的输入位置是否正确？\n&quot;);</span><br><span class="line">						printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">						scanf(&quot;%s&quot;, inputy);</span><br><span class="line">						if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">							flag = 1;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">							flag = 2;</span><br><span class="line">							printf(&quot;\n\n&quot;);</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 1) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (flag == 2) &#123;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				while (inputy[1] != &apos;0&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 确保输入为负数，要求输入负数的绝对值要&lt;1。\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputy);</span><br><span class="line">					if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">						flag = 2;</span><br><span class="line">						printf(&quot;\n\n&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 1) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (flag == 2) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				while (inputy[0] != &apos;-&apos; &amp;&amp; inputy[0] != &apos;0&apos;) &#123;</span><br><span class="line">					printf(&quot;[ERROR] 输入正数或负数，要求输入数的绝对值要&lt;1。\n&quot;);</span><br><span class="line">					printf(&quot;请重新输入乘数 Y : &quot;);</span><br><span class="line">					scanf(&quot;%s&quot;, inputy);</span><br><span class="line">				&#125;</span><br><span class="line">				if (compare(inputy, &quot;q&quot;) == 0 || compare(inputy, &quot;Q&quot;) == 0) &#123;</span><br><span class="line">					flag = 1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (compare(inputy, &quot;w&quot;) == 0 || compare(inputy, &quot;W&quot;) == 0) &#123;</span><br><span class="line">					flag = 2;</span><br><span class="line">					printf(&quot;\n\n&quot;);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag == 1) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag == 2) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		char origin[20] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">		// x补码</span><br><span class="line">		copy(origin, inputx);</span><br><span class="line">		calComplement(origin, xCom);</span><br><span class="line">		printf(&quot;-----------------------------------\n&quot;);</span><br><span class="line">		printf(&quot;[X]补 : %s\n&quot;, xCom);</span><br><span class="line"></span><br><span class="line">		// -x补码</span><br><span class="line">		copy(origin, inputx);</span><br><span class="line">		int lenx = length(origin);</span><br><span class="line">		/* 如果x本身就为负，那么直接将负号去掉即可得到-x */</span><br><span class="line">		if (inputx[0] == &apos;-&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			int i = 0;</span><br><span class="line">			for (; i &lt; lenx - 1; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				origin[i] = origin[i + 1];</span><br><span class="line">			&#125;</span><br><span class="line">			origin[i] = &apos;\0&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 如果x本身为正，那么添加负号得到-x */</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			for (int i = lenx - 1; i &gt;= 0; --i)</span><br><span class="line">			&#123;</span><br><span class="line">				origin[i + 1] = origin[i];</span><br><span class="line">			&#125;</span><br><span class="line">			origin[0] = &apos;-&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		calComplement(origin, mxCom);</span><br><span class="line">		printf(&quot;[-X]补 : %s\n&quot;, mxCom);</span><br><span class="line"></span><br><span class="line">		// y补码</span><br><span class="line">		copy(origin, inputy);</span><br><span class="line">		calComplement(origin, yCom);</span><br><span class="line">		printf(&quot;[Y]补 : %s\n&quot;, yCom);</span><br><span class="line"></span><br><span class="line">		// 乘数y的末尾补0</span><br><span class="line">		copy(origin, yCom);</span><br><span class="line">		int leny = length(origin);</span><br><span class="line">		int k = 0;</span><br><span class="line">		for (; k &lt; leny - 1; ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			origin[k] = origin[k + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		origin[k] = &apos;0&apos;;</span><br><span class="line">		origin[k + 1] = &apos;\0&apos;;</span><br><span class="line">		copy(multiNum, origin);</span><br><span class="line">		printf(&quot;乘数Y的末尾补0 : %s\n&quot;, multiNum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		// 计算部分积初值</span><br><span class="line">		multiSrc[0] = &apos;0&apos;;</span><br><span class="line">		multiSrc[1] = &apos;0&apos;;</span><br><span class="line">		multiSrc[2] = &apos;.&apos;;</span><br><span class="line">		int len = length(xCom) - 3;</span><br><span class="line">		int i = 0;</span><br><span class="line">		int j = 3;</span><br><span class="line">		for (; i &lt; len; ++i, ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			multiSrc[j] = &apos;0&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;部分积初值: %s\n\n&quot;, multiSrc);</span><br><span class="line"></span><br><span class="line">		/* Booth算法 */</span><br><span class="line">		Calculate();</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Booth</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置NFS+TFTP服务器</title>
    <url>/2019/11/04/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AENFS-TFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>

<h1 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h1><div class="note info">
<p>NFS（Network FileSystem），网络文件存储系统。</p>
</div>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>更新软件列表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure>

<p><strong>安装nfs服务器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo apt-get install nfs-kernel-server nfs-common</span><br></pre></td></tr></table></figure>

<p>其中：nfs-common是客户端、nfs-kernel-server是服务器端</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo vim /etc/export</span><br><span class="line"># /etc/exports: the access control list for filesystems which may be exported</span><br><span class="line">#               to NFS clients.  See exports(5).</span><br><span class="line">#</span><br><span class="line"># Example for NFSv2 and NFSv3:</span><br><span class="line"># /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)</span><br><span class="line">#</span><br><span class="line"># Example for NFSv4:</span><br><span class="line"># /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)</span><br><span class="line"># /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)</span><br><span class="line">/home/farsight/nfsdir *(rw,sync,no_subtree_check)</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2019/11/04/MGwDu7OC6gQHy9t.jpg" width="75%" height="75%" div align="center">

<div class="note default no-icon">
<p>

</p><p>NFS的配置文件/etc/exports，其格式如下：<br>&lt;共享目录&gt; 客户端1(选项) [客户端2(选项) …]<br>其中：<br>&emsp;&emsp;&emsp;&emsp;共享目录：NFS共享给客户机的目录。<br>&emsp;&emsp;&emsp;&emsp;客户端：网络中可以访问此目录的主机。多个客户端以空格分隔。<br>&emsp;&emsp;&emsp;&emsp;选项：设置目录的访问权限、用户映射等，多个选项以逗号分隔。<br>例如：<br>&emsp;&emsp;&emsp;&emsp;/home/farsight/nfsdir *(rw,sync,no_subtree_check)</p>
<p>客户端的指定方式<br>&emsp;&emsp;&emsp;&emsp;指定ip地址的主机：192.168.0.100<br>&emsp;&emsp;&emsp;&emsp;指定子网中的所有主机：192.168.0.0/24 或 192.168.0.0/255.255.255.0<br>&emsp;&emsp;&emsp;&emsp;指定域名的主机：nfs.farsight.com<br>&emsp;&emsp;&emsp;&emsp;指定域中的所有主机：<em>.farsight.com<br>&emsp;&emsp;&emsp;&emsp;所有主机：</em></p>
<p>选项说明<br>&emsp;&emsp;&emsp;&emsp;ro：共享目录只读；<br>&emsp;&emsp;&emsp;&emsp;rw：共享目录可读可写；<br>&emsp;&emsp;&emsp;&emsp;all_squash：所有访问用户都映射为匿名用户或用户组；<br>&emsp;&emsp;&emsp;&emsp;no_all_squash（默认）：访问用户先与本机用户匹配，匹配失败后再映射为匿名用户或用户组；<br>&emsp;&emsp;&emsp;&emsp;root_squash（默认）：将来访的root用户映射为匿名用户或用户组；<br>&emsp;&emsp;&emsp;&emsp;no_root_squash：来访的root用户保持root帐号权限；<br>&emsp;&emsp;&emsp;&emsp;anonuid=<uid>：指定匿名访问用户的本地用户UID，默认为nfsnobody（65534）；<br>&emsp;&emsp;&emsp;&emsp;anongid=<gid>：指定匿名访问用户的本地用户组GID，默认为nfsnobody（65534）；<br>&emsp;&emsp;&emsp;&emsp;secure（默认）：限制客户端只能从小于1024的tcp/ip端口连接服务器；<br>&emsp;&emsp;&emsp;&emsp;insecure：允许客户端从大于1024的tcp/ip端口连接服务器；<br>&emsp;&emsp;&emsp;&emsp;sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；<br>&emsp;&emsp;&emsp;&emsp;async：将数据先保存在内存缓冲区中，必要时才写入磁盘；<br>&emsp;&emsp;&emsp;&emsp;wdelay（默认）：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率；<br>&emsp;&emsp;&emsp;&emsp;no_wdelay：若有写操作则立即执行，应与sync配合使用；<br>&emsp;&emsp;&emsp;&emsp;subtree_check（默认） ：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限；<br>&emsp;&emsp;&emsp;&emsp;no_subtree_check ：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；</gid></uid></p>
<p></p>
</div>

<h2 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">停止服务器</span><br><span class="line"># sudo /etc/init.d/nfs-kernel-server stop</span><br><span class="line">[ ok ] Stopping nfs-kernel-server (via systemctl): nfs-kernel-server.service.</span><br><span class="line"></span><br><span class="line">启动服务器</span><br><span class="line"># sudo /etc/init.d/nfs-kernel-server start</span><br><span class="line">[ ok ] Starting nfs-kernel-server (via systemctl): nfs-kernel-server.service.</span><br><span class="line"></span><br><span class="line">重启服务器</span><br><span class="line"># sudo /etc/init.d/nfs-kernel-server restart</span><br><span class="line">[ ok ] Restarting nfs-kernel-server (via systemctl): nfs-kernel-server.service.</span><br></pre></td></tr></table></figure>

<h2 id="NFS相关命令"><a href="#NFS相关命令" class="headerlink" title="NFS相关命令"></a>NFS相关命令</h2><div class="note default no-icon">
<p>

</p><p><strong>exportfs</strong><br>&emsp;&emsp;不重启nfs服务应用更新，相关选项如下：<br>&emsp;&emsp;-a 全部挂载或卸载 /etc/exports中的内容<br>&emsp;&emsp;-r 重新读取/etc/exports 中的信息 ，并同步更新/etc/exports、/var/lib/nfs/xtab<br>&emsp;&emsp;-u 卸载单一目录（和-a一起使用为卸载所有/etc/exports文件中的目录）<br>&emsp;&emsp;-v 在export的时候，将详细的信息输出到屏幕上。</p>
<p><strong>nfsstat</strong><br>&emsp;&emsp;查看NFS的运行状态。</p>
<p><strong>rpcinfo</strong><br>&emsp;&emsp;查看rpc服务注册情况。<br>&emsp;&emsp;相关选项：<br>&emsp;&emsp;-p 显示所有的端口与程序信息。<br>&emsp;&emsp;示例：<br>&emsp;&emsp;rpcinfo -p localhost  #列出本机的RPC注册状况。</p>
<p><strong>showmount</strong><br>&emsp;&emsp;查询nfs共享目录信息，相关选项如下：<br>&emsp;&emsp;-a 显示已经于客户端连接上的目录信息<br>&emsp;&emsp;-e IP或者hostname 显示此IP地址分享出来的目录</p>
<p></p>
</div>

<h2 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock nfs服务器主机名/IP:/nfs共享目录 /挂载目录</span><br></pre></td></tr></table></figure>

<h1 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h1><div class="note info">
<p>TFTP（Trivial File Transfer Protocol），简单文件传输协议。</p>
</div>

<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><strong>更新软件列表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure>

<p><strong>安装tftpd-hpa服务器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo apt-get install tftpd-hpa tftp-hpa</span><br></pre></td></tr></table></figure>

<h2 id="查看客户端tftp和服务器tftpd的帮助文档"><a href="#查看客户端tftp和服务器tftpd的帮助文档" class="headerlink" title="查看客户端tftp和服务器tftpd的帮助文档"></a>查看客户端tftp和服务器tftpd的帮助文档</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># man tftp</span><br><span class="line">tftp [ options... ] [host [port]] [-c command]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># man tftpd</span><br><span class="line">in.tftpd [options...]  directory...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo vim /etc/default/tftped-hpa</span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;			# 默认登录的用户名</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/farsight/tftpdir&quot; # 这是tftpd-hpa服务器的下载目录【这个目录是随意选的】</span><br><span class="line">TFTP_ADDRESS=&quot;0.0.0.0:69&quot;		# 指定ip和端口号</span><br><span class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</span><br><span class="line"></span><br><span class="line"># -l：以standalone/listen模式启动TFTP服务，而不是从xinetd启动</span><br><span class="line"># -c：可创建新文件。默认情况下TFTP只允许覆盖原有文件而不能创建新文件</span><br><span class="line"># -s：改变TFTP启动的根目录，加了-s后，客户端使用TFTP时，不再需要输入指定目录，而是使用配置文件中写好的目录。</span><br></pre></td></tr></table></figure>

<h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">停止服务器</span><br><span class="line"># sudo /etc/init.d/tftpd-hpa stop</span><br><span class="line">[ ok ] Stopping tftpd-hpa (via systemctl): tftpd-hpa.service.</span><br><span class="line"></span><br><span class="line">启动服务器</span><br><span class="line"># sudo /etc/init.d/tftpd-hpa start</span><br><span class="line">[ ok ] Starting tftpd-hpa (via systemctl): tftpd-hpa.service.</span><br><span class="line"></span><br><span class="line">重启服务器</span><br><span class="line"># sudo /etc/init.d/tftpd-hpa restart</span><br><span class="line">[ ok ] Restarting tftpd-hpa (via systemctl): tftpd-hpa.service.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tftp 192.168.2.1</span><br><span class="line">tftp&gt; ?</span><br><span class="line">tftp-hpa 5.2</span><br><span class="line">Commands may be abbreviated.  Commands are:</span><br><span class="line"></span><br><span class="line">connect 	connect to remote tftp</span><br><span class="line">mode    	set file transfer mode</span><br><span class="line">put     	send file</span><br><span class="line">get     	receive file</span><br><span class="line">quit    	exit tftp</span><br><span class="line">verbose 	toggle verbose mode</span><br><span class="line">trace   	toggle packet tracing</span><br><span class="line">literal 	toggle literal mode, ignore &apos;:&apos; in file name</span><br><span class="line">status  	show current status</span><br><span class="line">binary  	set mode to octet</span><br><span class="line">ascii   	set mode to netascii</span><br><span class="line">rexmt   	set per-packet transmission timeout</span><br><span class="line">timeout 	set total retransmission timeout</span><br><span class="line">?       	print help information</span><br><span class="line">help    	print help information</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2019/11/04/XGbcpyj7PtVawQK.jpg" width="75%" height="75%" div align="center">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp&gt; get 文件名</span><br><span class="line">tftp&gt; put 文件名</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tftp 192.168.2.131</span><br><span class="line"></span><br><span class="line">tftp&gt; put 1.txt</span><br><span class="line">tftp: 1.txt: No such file or directory ---&gt; 当前目前下没有文件a</span><br><span class="line"></span><br><span class="line">tftp&gt; put 2.txt</span><br><span class="line">Error code 1: File not found ---&gt; 服务器不允许上传文件</span><br></pre></td></tr></table></figure>

<hr>]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>NFS</tag>
        <tag>TFTP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/2019/11/04/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>

<p><strong>参考</strong>：<a href="https://blog.csdn.net/qq_36903042/article/details/102513465" target="_blank" rel="noopener">动画：用动画给面试官解释 TCP 三次握手过程</a><br>&emsp;&emsp;&emsp;<a href="https://mp.weixin.qq.com/s/8t_KFtrrBkFyZKPJg_y6pw" target="_blank" rel="noopener">关于三次握手与四次挥手面试官想考我们什么？</a></p>
<br>

<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h2 id="TCP是什么？🚀"><a href="#TCP是什么？🚀" class="headerlink" title="TCP是什么？🚀"></a>TCP是什么？<a href="https://baike.baidu.com/item/TCP/33012" target="_blank" rel="noopener">🚀</a></h2><div class="note default no-icon">
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>简单通俗的说就是网络通讯协议。</p>
<p>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
</div>

<br>

<h2 id="TCP-头部报文"><a href="#TCP-头部报文" class="headerlink" title="TCP 头部报文"></a>TCP 头部报文</h2><img src="https://i.loli.net/2019/11/04/W9m7tpIEvVCkc6N.png" width="60%" height="60%" div align="center">
<img src="https://i.loli.net/2019/11/04/OrsuXxFmaT1qSPi.jpg" width="60%" height="60%" div align="center">

<h3 id="Source-Port-和-Destination-Port"><a href="#Source-Port-和-Destination-Port" class="headerlink" title="Source Port 和 Destination Port"></a>Source Port 和 Destination Port</h3><div class="note info no-icon">
<p>Source Port是【源端口】，指本地端口。</p>
<p>Destination Port是【目的端口】，指远程端口。</p>
</div>

<h3 id="Sequence-Numbe"><a href="#Sequence-Numbe" class="headerlink" title="Sequence Numbe"></a>Sequence Numbe</h3><div class="note info no-icon">
<p>发送数据包中的第一个字节的序列号。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。</p>
</div>

<h3 id="Acknowledgment-Numbe"><a href="#Acknowledgment-Numbe" class="headerlink" title="Acknowledgment Numbe"></a>Acknowledgment Numbe</h3><div class="note info no-icon">
<p>确认序列号，主要用来解决不丢包的问题。</p>
</div>

<h3 id="TCP-Flag"><a href="#TCP-Flag" class="headerlink" title="TCP Flag"></a>TCP Flag</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标志位：6位</span><br><span class="line"> URG表示Urgent Pointer字段有意义</span><br><span class="line"> ACK表示Acknowledgment Number字段有意义</span><br><span class="line"> PSH表示Push功能</span><br><span class="line"> RST表示复位TCP连接</span><br><span class="line"> SYN表示SYN报文（在建立TCP连接的时候使用）</span><br><span class="line"> FIN表示没有数据需要发送了（在关闭TCP连接的时候使用）</span><br></pre></td></tr></table></figure>

<p><strong><em>需注意：</em></strong><br><strong><font color="red">ACK</font></strong> ：此标志表示「应答域有效」，就是说前面所说的TCP应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；<br><strong><font color="red">SYN</font></strong> ：表示「同步序列号」，是 TCP 握手的发送的第一个数据包。<br><strong><font color="red">FIN</font></strong> ：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p>
<h3 id="Window-size"><a href="#Window-size" class="headerlink" title="Window size"></a>Window size</h3><p>称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。</p>
<h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>校验和。</p>
<h3 id="Urgent-Pointers"><a href="#Urgent-Pointers" class="headerlink" title="Urgent Pointers"></a>Urgent Pointers</h3><p>紧急指针。</p>
<h2 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h2><p><img src="https://i.loli.net/2019/11/04/yFmke4jTow1Wsxq.png" alt="tcp_3"><br><strong>初始状态</strong>：客户端处于<font color="blue">closed</font> 状态，服务端处于 <font color="blue">listen</font> 状态。<br><strong>第一次握手</strong>：客户端给服务端发送一个<font color="blue">SYN</font>报文，并指明了客户端的初始序列号<font color="blue">ISN(c)</font>，发送完之后客户端处于<font color="blue">SYN_Send</font>状态。<br><strong>第二次握手</strong>：服务端收到客户端的<font color="blue">SYN</font>报文之后，如果同意连接，会以自己的<font color="blue">SYN</font>报文作为应答，并指明了自己的初始化序列号<font color="blue">ISN(s)</font>，服务端将发送报文：<font color="blue">SYN(服务端) 和 SYN(客户端)+1 (ACK)</font>，表示已经收到了客户端的<font color="blue">SYN</font>报文，此时服务器处于<font color="blue">SYN_Recive</font>状态。<br><strong>第三次握手</strong>：客户端收到服务端的<font color="blue">ACK</font>报文之后，会发送一个<font color="blue">SYN(服务端)+1 (ACK)</font>报文作为应答，表示已经收到了服务端的<font color="blue">SYN+ACK</font>报文。此时客户端处于<font color="blue">established</font>状态。<br><strong>最后</strong>：服务器收到了客户端的<font color="blue">ACK</font>报文之后，此时服务端处于<font color="blue">established</font>状态。</p>
<h2 id="为什么进行三次握手？（三次握手的作用）"><a href="#为什么进行三次握手？（三次握手的作用）" class="headerlink" title="为什么进行三次握手？（三次握手的作用）"></a>为什么进行三次握手？（三次握手的作用）</h2><div class="note warning no-icon">
<p>1、确认双方的接收能力与发送能力是否正常。</p>
<p>2、指定自己的初始化序列号，为后面的可靠传送做准备。</p>
<p>3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
</div>

<br>

<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><strong>第一次挥手</strong>：客户端发送一个 <font color="blue">FIN</font> 报文，报文中会指定一个序列号。此时客户端处于<font color="blue">CLOSED_WAIT1</font>状态。</p>
<p><strong>第二次握手</strong>：服务端收到 <font color="blue">FIN</font> 之后，会发送 <font color="blue">ACK</font> 报文，且把客户端的序列号值 <font color="blue">+ 1</font> 作为 <font color="blue">ACK</font> 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <font color="blue">CLOSE_WAIT2</font>状态。</p>
<p><strong>第三次挥手</strong>：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <font color="blue">FIN</font> 报文，且指定一个序列号。此时服务端处于 <font color="blue">LAST_ACK</font> 的状态。</p>
<p><strong>第四次挥手</strong>：客户端收到 <font color="blue">FIN</font> 之后，一样发送一个 <font color="blue">ACK</font> 报文作为应答，且把服务端的序列号值 <font color="blue">+ 1</font> 作为自己 <font color="blue">ACK</font> 报文的序列号值，此时客户端处于 <font color="blue">TIME_WAIT</font> 状态。需要过一阵子以确保服务端收到自己的 <font color="blue">ACK</font> 报文之后才会进入 <font color="blue">CLOSED</font> 状态</p>
<p>5、服务端收到 <font color="blue">ACK</font> 报文之后，就处于关闭连接了，处于 <font color="blue">CLOSED</font> 状态。</p>
<hr>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title>罗辑 "星海横流"</title>
    <url>/2019/10/28/%E7%BD%97%E8%BE%91%E6%98%9F%E6%B5%B7%E6%A8%AA%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<h4 id="面壁者-·-罗辑"><a href="#面壁者-·-罗辑" class="headerlink" title="面壁者 · 罗辑"></a>面壁者 · 罗辑</h4><p>&emsp;&emsp;他走上高速公路，等了几分钟后拦住了一辆车，车里是一家三口，他们很热情地让他搭上了车。这一家子是返回旧城的冬眠者，孩子还小，母亲也很年轻，他们三个人挤在前座上窃窃私语，那孩子不时把脑袋钻到妈妈怀中，每到这时三人就一起笑起来。罗辑陶醉地看着，他听不清他们说什么，因为车里放着音乐，是20世纪的老歌，一路上罗辑听了五六首，其中有《喀秋莎》和《红莓花儿开》，于是他满心希望能听到《山楂树》，这是两个世纪前他在那个村前的大戏台上为想象中的爱人唱过的，后来，在那个北欧的伊甸园中，在倒映着雪山的湖边，他也和庄颜一起唱过这首歌。</p>
<p>&emsp;&emsp;这时，一辆车迎面开来，车灯照亮了后座，孩子无意中回头看了一眼，然后盯着罗辑叫道：“呀，他好像是面壁者呀！”于是孩子的父母也都回头看他，他只好承认自己就是罗辑。</p>
<p>&emsp;&emsp;这时，车内响起了《山楂树》。</p>
<p>&emsp;&emsp;车停了下来，“下去。”孩子的父亲冷冷地说，母亲和孩子看他的眼光也如外面的秋雨般冰凉。</p>
<p>&emsp;&emsp;罗辑没有动，他想听那首歌。</p>
<p>&emsp;&emsp;“请下去。”那男人又说，罗辑读出了他们目光中的含义：没有救世的能力不是你的错，但给世界以希望后又打碎它则是一种不可饶恕的罪恶。</p>
<p>&emsp;&emsp;罗辑只好起身下车，他的旅行包随后被扔了出来，车启动时他跟着跑了几步，想再听听那首歌，但《山楂树》很快就消失在冰冷的雨夜中。</p>
<p>&emsp;&emsp;他像一位孤独的行者，义无反顾的走向自己的归宿。</p>
<p>&emsp;&emsp;车是半空的，坐了六七个人，看上去也都是旧城的冬眠者居民。车里的人们都不说话，默默地感觉着这秋夜的阴郁。一路上很顺利，但一个多小时后还是有人认出了罗辑，于是车里的人一致要求他下车。罗辑争辩说自己已经输入信用点买了票，当然有权坐车。有一个头发花白的老者章出了两枚现在已经很不常见的现金属硬币扔给了他，他还是被赶下了车。</p>
<p>&emsp;&emsp;“面壁者，你背把铁锹干什么？”车开时有人从车窗探出头问。</p>
<p>&emsp;&emsp;“为自己挖墓。”罗辑说，引起了车里的一阵哄笑。</p>
<p>&emsp;&emsp;没人知道他说的是真话。</p>
<hr>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>罗辑</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 发表博客常用命令</title>
    <url>/2019/10/28/Hexo-%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<h1 id="与君共勉"><a href="#与君共勉" class="headerlink" title="与君共勉"></a>与君共勉</h1><br>

<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure>

<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new draft &quot;new draft&quot;</span><br><span class="line">$ hexo --draft  #显示草稿</span><br></pre></td></tr></table></figure>

<h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server   #启动服务预览</span><br></pre></td></tr></table></figure>

<h3 id="hexo-clean-amp-amp-hexo-g-amp-amp-hexo-d"><a href="#hexo-clean-amp-amp-hexo-g-amp-amp-hexo-d" class="headerlink" title="hexo clean &amp;&amp; hexo g &amp;&amp; hexo d"></a>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean    #清理缓存文件</span><br><span class="line">$ hexo generate #生成静态文件</span><br><span class="line">$ hexo deploy   #部署到远程站点</span><br><span class="line">                #每次发布时，使用 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --safe   #表示安全模式，用于禁用加载插件和脚本</span><br><span class="line">$ hexo --debug  #表示调试模式，用于将消息详细记录到终端和 debug.log 文件</span><br><span class="line">$ hexo --silent #表示静默模式，用于静默输出到终端</span><br></pre></td></tr></table></figure>

<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo version  #显示 Hexo 版本。</span><br></pre></td></tr></table></figure>

<hr>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next集成Algolia搜索</title>
    <url>/2019/10/26/Hexo-Next%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<h1 id="集成Algolia搜索"><a href="#集成Algolia搜索" class="headerlink" title="集成Algolia搜索"></a>集成Algolia搜索</h1><p>&emsp;&emsp;NexT 支持集成 Swiftype、 微搜索、Local Search 和 Algolia。鉴于Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。</p>
<p><strong><em>注：</em></strong>Algolia搜索在版本<strong>5.1.0</strong>中引入，要使用此功能请确保所使用的 NexT 版本在此之后。</p>
<p>&emsp;&emsp;前往 <a href="https://www.algolia.com/" target="_blank" rel="noopener">Algolia 注册页面</a>，注册一个新账户。 可以使用 <em>GitHub</em> 或者 <em>Google</em> 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。</p>
<br>

<h1 id="注册Algolia，创建Index"><a href="#注册Algolia，创建Index" class="headerlink" title="注册Algolia，创建Index"></a>注册Algolia，创建Index</h1><p>&emsp;&emsp;注册完成后，创建一个新的 Index，这个 Index 将在后面使用。我这里已经创建好了，所以你也可以在这里选择再新建一个。创建过程就不说了，跟着官网步骤来就行了。</p>
<p><img src="https://i.loli.net/2019/10/26/L7BjRO8vKN5aHxW.png" alt="step1"></p>
<p><img src="https://i.loli.net/2019/10/26/6yiV1mzTbS4tHfX.png" alt="step1_1"></p>
<br>

<h1 id="安装-Hexo-Algolia"><a href="#安装-Hexo-Algolia" class="headerlink" title="安装 Hexo Algolia"></a>安装 Hexo Algolia</h1><p>&emsp;&emsp;Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 <a href="https://github.com/oncletom/hexo-algolia" target="_blank" rel="noopener">Hexo Algolia</a> 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：</p>
<div class="note success"><p>npm install --save hexo-algolia </p></div>

<br>

<h1 id="获取Key，更新站点配置"><a href="#获取Key，更新站点配置" class="headerlink" title="获取Key，更新站点配置"></a>获取Key，更新站点配置</h1><p><img src="https://i.loli.net/2019/10/26/4y98jlXKYxtCP6w.png" alt="keys"></p>
<p>&emsp;&emsp;前往站点根目录打开<code>站点配置文件</code>，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">algolia: </span><br><span class="line">    applicationID: &apos;你的Application ID&apos;</span><br><span class="line">    apiKey: &apos;你的Search-Only API Key&apos;</span><br><span class="line">    indexName: &apos;输入刚才创建index name&apos;</span><br><span class="line">    chunkSize: 5000</span><br></pre></td></tr></table></figure>

<br>

<h2 id="修改Algolia搜索ACL（访问控制列表）"><a href="#修改Algolia搜索ACL（访问控制列表）" class="headerlink" title="修改Algolia搜索ACL（访问控制列表）"></a>修改Algolia搜索ACL（访问控制列表）</h2><p>&emsp;&emsp;找到新建INDEX对应的API key， 编辑权限。<br>&emsp;&emsp;我当时在做的时候，发现编辑不了，提示：“This API Key was created automatically and cannot be edited.(此 API 密钥是自动创建的，无法编辑。)”，索性就新建了一个API Key。</p>
<p><img src="https://i.loli.net/2019/10/26/DsWcMhgJC73xtyP.png" alt="apikey"></p>
<p>&emsp;&emsp;勾选以下选项。<br><img src="https://i.loli.net/2019/10/26/wQz9Ack8YXsnyir.png" alt="xuanxiang"></p>
<p>&emsp;&emsp;完成后点击 Update<br><br></p>
<h1 id="更新-Index"><a href="#更新-Index" class="headerlink" title="更新 Index"></a>更新 Index</h1><p>&emsp;&emsp;当配置完成，在站点根目录下执行：</p>
<div class="note warning no-icon">
<p>$ export(windows 为 set) HEXO_ALGOLIA_INDEXING_KEY=Search-Only API key</p>
<p>$ hexo algolia</p>
</div>
&emsp;&emsp;替换Search-Only API key为你自己的API Key。

<img src="https://i.loli.net/2019/10/26/algpEZs1bt5XUzy.jpg" width="50%" height="50%" div align="center">

<br>

<h1 id="主题集成"><a href="#主题集成" class="headerlink" title="主题集成"></a>主题集成</h1><p>&emsp;&emsp;更改<code>主题配置文件</code>，找到 Algolia Search 配置部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: 请输入关键字...</span><br><span class="line">    hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;找到$&#123;hits&#125;条相关记录，共耗时 $&#123;time&#125; ms&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。</p>
<p><img src="https://i.loli.net/2019/10/26/78vIGhOog1qzceZ.jpg" alt="search"></p>
<br>

<h1 id="可能存在的BUG"><a href="#可能存在的BUG" class="headerlink" title="可能存在的BUG"></a>可能存在的BUG</h1><p>&emsp;&emsp;移动端遮罩盖住搜索<br><img src="https://i.loli.net/2019/10/26/TL1SxoensCArfK6.png" alt="phone"></p>
<p>&emsp;&emsp;原因：遮罩的z-index值太高，我的next主题是5.1.4版本。<br>&emsp;&emsp;解决方案： 找到themes\next\source\css_common\components\third-party 下面的 algolia-search.styl 文件 第8行追加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+mobile()</span><br><span class="line">z-index: 1000</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2019/10/26/VgmvRnOCA2l9fzj.png" width="88%" height="88%" div align="center">

<p>&emsp;&emsp;即可。</p>
<br>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><em>感谢掘金的一位博主</em>   <a href="https://juejin.im/post/5af3f9d1518825673e35a6eb" target="_blank" rel="noopener">jilei786</a><br><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">官方文档</a><br><a href="https://stackoverflow.com/questions/36915651/not-enough-rights-to-add-an-object-error-while-implementing-algolia?answertab=votes" target="_blank" rel="noopener">StackOverflow</a></p>
<hr>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title>颠覆世界的“自由主义教皇”林纳斯</title>
    <url>/2019/07/01/Linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a> 
<br>


<p><em>—  —  我的名字是Linus Torvalds，我是你们的上帝。</em>（在1998 Linux大会上的自我介绍）  </p>
<br>

<p>“有些人生来就具有统率百万人的领袖风范；另一些人则是为写出颠覆世界的软件而生。唯一一个能同时做到这两者的人，就是托瓦兹。”美国《<a href="https://baike.baidu.com/item/%E6%97%B6%E4%BB%A3/1944848" target="_blank" rel="noopener">时代</a>》周刊对“<a href="https://baike.baidu.com/item/Linux/27050" target="_blank" rel="noopener">Linux</a>之父”林纳斯·托瓦兹（Linus Torvalds）给出了极高的评价。甚至，在《时代》周刊根据读者投票评选出的二十世纪100位最重要人物中，林纳斯居然排到了第15位，而从20世纪的最后几年就开始霸占全球首富称号的<a href="https://baike.baidu.com/item/%E6%AF%94%E5%B0%94%C2%B7%E7%9B%96%E8%8C%A8/83241?fromtitle=%E7%9B%96%E8%8C%A8&fromid=14487" target="_blank" rel="noopener">盖茨</a>不过才是第17位。</p>
<p>林纳斯的出名和“重要”来得并没什么先兆，尽管这个1969年出生在芬兰赫尔辛基的天才在年少时就已经颇具黑客神韵—对于电脑的着迷使他很早就能够驱使电脑做事情，对一切细节也都能控制自如。但当林纳斯在1991年就读于赫尔辛基大学期间刚刚开始对<a href="https://baike.baidu.com/item/Unix" target="_blank" rel="noopener">Unix</a>产生浓厚兴趣，尝试着在<a href="https://baike.baidu.com/item/Minix" target="_blank" rel="noopener">Minix</a>（Unix的变种）上做一些开发工作的时候，他从来也没想过会构建出一个新操作系统的内核来。</p>
<p>Linux的诞生显得充满了偶然。林纳斯经常要用他的终端仿真器（Terminal Emulator）去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了<em>磁盘驱动</em>程序和<em>文件系统</em>，这些在后来成为了Linux第一个内核的雏形。当时，他年仅21岁。</p>
<p>在<a href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">自由软件</a>之父<a href="https://baike.baidu.com/item/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC" target="_blank" rel="noopener">理查德·斯托曼</a>（Richard Stallman）某些精神的感召下，林纳斯很快以Linux的名字把这款类Unix的操作系统加入到了自由软件基金（<a href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A/6653246?fromtitle=FSF&fromid=2356953" target="_blank" rel="noopener">FSF</a>）的<a href="https://baike.baidu.com/item/GNU%E8%AE%A1%E5%88%92" target="_blank" rel="noopener">GNU计划</a>中，并通过<a href="https://baike.baidu.com/item/GPL/2357903" target="_blank" rel="noopener">GPL</a>的通用性授权，允许用户销售、拷贝并且改动程序，但你必须将同样的自由传递下去，而且必须免费公开你修改后的代码。这说明，Linux并不是被刻意创造的，它完全是日积月累的结果，是经验、创意和一小段一小段代码的集合体。</p>
<p>无疑，正是林纳斯的这一举措带给了Linux和他自己巨大的成功和极高的声誉。短短几年间，在Linux身边已经聚集了成千上万的狂热分子，大家不计得失的为Linux增补、修改，并随之将开源运动的自由主义精神传扬下去，人们几乎像看待神明一样对林纳斯顶礼膜拜。</p>
<p>然而，在1996年底，林纳斯突然离开<a href="https://baike.baidu.com/item/%E8%B5%AB%E5%B0%94%E8%BE%9B%E5%9F%BA" target="_blank" rel="noopener">赫尔辛基</a>，只身奔赴美国硅谷，成为Transmeta公司的一员，直到2003年才离开。其中的原因曾经扑朔迷离，但现在看来，那只不过是林纳斯对于自身价值的一种现实性追求。虽然当时许多人都怀疑这会给发展中的Linux造成致命伤害，不过Linux在随后几年内的发展证明，这样的担心是多余的。</p>
<p>林纳斯说，Linux所取得的许多成功其实可以归结为他的缺点所致。“我很懒散，我喜欢授权给其他人。”就连Linux的企鹅形象标识也是林纳斯的妻子，曾获芬兰空手道冠军的托芙（Tove）想到的，因为林纳斯曾经在澳大利亚被一只企鹅咬过。“黑客们，不，程序员们，把在Linux和其它<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">开放源代码</a>项目上的工作，放在比睡觉、锻炼身体、娱乐和聚会更优先的地位。因为他们乐于成为一个全球协作努力活动的一部分 — Linux是世界上最大的协作项目。”</p>
<p><em>— — 摘自<a href="https://baike.baidu.com/" target="_blank" rel="noopener">百度百科</a></em></p>
]]></content>
      <categories>
        <category>人物</category>
      </categories>
      <tags>
        <tag>林纳斯</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Let's Go！</title>
    <url>/2019/06/29/My-first-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<div class="note success">

<p>success</p>

<p>1、不要在乎别人如何看你，要在乎你自己如何看未来，看梦想，看世界..!</p>

<p>2、世界上最宝贵的财富就是时间，所以不要浪费一分一秒！</p>

<p>3、从来如此，便对么？</p>

<p>4、永远把别人对自己的批评记在心里，别人的表扬，就把它忘了。</p>

<p>5、永远要相信边上的人比自己聪明。</p>

<p>6、认识自己的无知是认识世界的最可靠的方法。</p>

<p>7、不要把软弱展示给任何人看！</p>

<p>8、要学会换不同的角度去看待这个世界，生活才能有新意。</p>

<p>9、闻道有先后，术业有专攻，如是而已。</p>

<p>10、每天都有很强大的起床的动力，用心去拥抱每个时刻，珍惜美好的人与物。</p>

</div>  

<hr>

]]></content>
      <categories>
        <category>ME</category>
      </categories>
      <tags>
        <tag>摘录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/06/26/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><br>
<a id="more"></a>
<br>

<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
